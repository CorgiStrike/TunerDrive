package frc.robot.generated;

import com.ctre.phoenix6.configs.CANcoderConfiguration;
import com.ctre.phoenix6.configs.CurrentLimitsConfigs;
import com.ctre.phoenix6.configs.Pigeon2Configuration;
import com.ctre.phoenix6.configs.Slot0Configs;
import com.ctre.phoenix6.configs.TalonFXConfiguration;
import com.ctre.phoenix6.mechanisms.swerve.SwerveDrivetrainConstants;
import com.ctre.phoenix6.mechanisms.swerve.SwerveModuleConstants;
import com.ctre.phoenix6.mechanisms.swerve.SwerveModuleConstantsFactory;
import com.ctre.phoenix6.mechanisms.swerve.SwerveModule.ClosedLoopOutputType;
import com.ctre.phoenix6.mechanisms.swerve.SwerveModuleConstants.SteerFeedbackType;

import edu.wpi.first.math.util.Units;

// Generated by the Tuner X Swerve Project Generator
// https://v6.docs.ctr-electronics.com/en/stable/docs/tuner/tuner-swerve/index.html
public class TunerConstants {
// Both sets of gains need to be tuned to your individual robot.

// The steer motor uses any SwerveModule.SteerRequestType control request with the
// output type specified by SwerveModuleConstants.SteerMotorClosedLoopOutput
private static final Slot0Configs steerGains = new Slot0Configs()
        .withKP(100).withKI(0).withKD(0.2)
        .withKS(0).withKV(1.5).withKA(0);
// When using closed-loop control, the drive motor uses the control
// output type specified by SwerveModuleConstants.DriveMotorClosedLoopOutput
private static final Slot0Configs driveGains = new Slot0Configs()
        .withKP(3).withKI(0).withKD(0)
        .withKS(0).withKV(0).withKA(0);

// The closed-loop output type to use for the steer motors;
// This affects the PID/FF gains for the steer motors
private static final ClosedLoopOutputType steerClosedLoopOutput = ClosedLoopOutputType.Voltage;
// The closed-loop output type to use for the drive motors;
// This affects the PID/FF gains for the drive motors
private static final ClosedLoopOutputType driveClosedLoopOutput = ClosedLoopOutputType.Voltage;

// The stator current at which the wheels start to slip;
// This needs to be tuned to your individual robot
private static final double slipCurrentA = 150.0;

// Initial configs for the drive and steer motors and the CANcoder; these cannot be null.
// Some configs will be overwritten; check the `with*InitialConfigs()` API documentation.
private static final TalonFXConfiguration driveInitialConfigs = new TalonFXConfiguration();
private static final TalonFXConfiguration steerInitialConfigs = new TalonFXConfiguration()
        .withCurrentLimits(
        new CurrentLimitsConfigs()
                // Swerve azimuth does not require much torque output, so we can set a relatively low
                // stator current limit to help avoid brownouts without impacting performance.
                .withStatorCurrentLimit(60)
                .withStatorCurrentLimitEnable(true)
        );
private static final CANcoderConfiguration cancoderInitialConfigs = new CANcoderConfiguration();
// Configs for the Pigeon 2; leave this null to skip applying Pigeon 2 configs
private static final Pigeon2Configuration pigeonConfigs = null;

// Theoretical free speed (m/s) at 12v applied output;
// This needs to be tuned to your individual robot
public static final double speedAt12VoltsMps = 10.43;

// Every 1 rotation of the azimuth results in kCoupleRatio drive motor turns;
// This may need to be tuned to your individual robot
private static final double coupleRatio = 3.5714285714285716;

private static final double driveGearRatio = 6.122448979591837;
private static final double steerGearRatio = 21.428571428571427;

private static final double wheelRadiusInches = 2;

private static final boolean invertLeftSide = false;
private static final boolean invertRightSide = true;

private static final String CANbusName = "Default Name";
private static final int pigeonId = 60;


// These are only used for simulation
private static final double steerInertia = 0.00001;
private static final double driveInertia = 0.001;
// Simulated voltage necessary to overcome friction
private static final double steerFrictionVoltage = 0.25;
private static final double driveFrictionVoltage = 0.25;

public static final SwerveDrivetrainConstants DrivetrainConstants = new SwerveDrivetrainConstants()
        .withCANbusName(CANbusName)
        .withPigeon2Id(pigeonId)
        .withPigeon2Configs(pigeonConfigs);

private static final SwerveModuleConstantsFactory ConstantCreator = new SwerveModuleConstantsFactory()
        .withDriveMotorGearRatio(driveGearRatio)
        .withSteerMotorGearRatio(steerGearRatio)
        .withWheelRadius(wheelRadiusInches)
        .withSlipCurrent(slipCurrentA)
        .withSteerMotorGains(steerGains)
        .withDriveMotorGains(driveGains)
        .withSteerMotorClosedLoopOutput(steerClosedLoopOutput)
        .withDriveMotorClosedLoopOutput(driveClosedLoopOutput)
        .withSpeedAt12VoltsMps(speedAt12VoltsMps)
        .withSteerInertia(steerInertia)
        .withDriveInertia(driveInertia)
        .withSteerFrictionVoltage(steerFrictionVoltage)
        .withDriveFrictionVoltage(driveFrictionVoltage)
        .withFeedbackSource(SteerFeedbackType.FusedCANcoder)
        .withCouplingGearRatio(coupleRatio)
        .withDriveMotorInitialConfigs(driveInitialConfigs)
        .withSteerMotorInitialConfigs(steerInitialConfigs)
        .withCANcoderInitialConfigs(cancoderInitialConfigs);


// Front Left
private static final int kFrontLeftDriveMotorId = 20;
private static final int kFrontLeftSteerMotorId = 21;
private static final int kFrontLeftEncoderId = 20;
private static final double kFrontLeftEncoderOffset = -0.197754;
private static final boolean kFrontLeftSteerInvert = true;

private static final double kFrontLeftXPosInches = 12.375;
private static final double kFrontLeftYPosInches = 12.375;

// Front Right
private static final int kFrontRightDriveMotorId = 26;
private static final int kFrontRightSteerMotorId = 27;
private static final int kFrontRightEncoderId = 23;
private static final double kFrontRightEncoderOffset = -0.346436;
private static final boolean kFrontRightSteerInvert = true;

private static final double kFrontRightXPosInches = 12.375;
private static final double kFrontRightYPosInches = -12.375;

// Back Left
private static final int kBackLeftDriveMotorId = 22;
private static final int kBackLeftSteerMotorId = 23;
private static final int kBackLeftEncoderId = 21;
private static final double kBackLeftEncoderOffset = -0.241699;
private static final boolean kBackLeftSteerInvert = true;

private static final double kBackLeftXPosInches = -12.375;
private static final double kBackLeftYPosInches = 12.375;

// Back Right
private static final int kBackRightDriveMotorId = 24;
private static final int kBackRightSteerMotorId = 25;
private static final int kBackRightEncoderId = 22;
private static final double kBackRightEncoderOffset = -0.037598;
private static final boolean kBackRightSteerInvert = true;

private static final double kBackRightXPosInches = -12.375;
private static final double kBackRightYPosInches = -12.375;


public static final SwerveModuleConstants FrontLeft = ConstantCreator.createModuleConstants(
        kFrontLeftSteerMotorId, kFrontLeftDriveMotorId, kFrontLeftEncoderId, kFrontLeftEncoderOffset, Units.inchesToMeters(kFrontLeftXPosInches), Units.inchesToMeters(kFrontLeftYPosInches), invertLeftSide)
        .withSteerMotorInverted(kFrontLeftSteerInvert);
public static final SwerveModuleConstants FrontRight = ConstantCreator.createModuleConstants(
        kFrontRightSteerMotorId, kFrontRightDriveMotorId, kFrontRightEncoderId, kFrontRightEncoderOffset, Units.inchesToMeters(kFrontRightXPosInches), Units.inchesToMeters(kFrontRightYPosInches), invertRightSide)
        .withSteerMotorInverted(kFrontRightSteerInvert);
public static final SwerveModuleConstants BackLeft = ConstantCreator.createModuleConstants(
        kBackLeftSteerMotorId, kBackLeftDriveMotorId, kBackLeftEncoderId, kBackLeftEncoderOffset, Units.inchesToMeters(kBackLeftXPosInches), Units.inchesToMeters(kBackLeftYPosInches), invertLeftSide)
        .withSteerMotorInverted(kBackLeftSteerInvert);
public static final SwerveModuleConstants BackRight = ConstantCreator.createModuleConstants(
        kBackRightSteerMotorId, kBackRightDriveMotorId, kBackRightEncoderId, kBackRightEncoderOffset, Units.inchesToMeters(kBackRightXPosInches), Units.inchesToMeters(kBackRightYPosInches), invertRightSide)
        .withSteerMotorInverted(kBackRightSteerInvert);
}
